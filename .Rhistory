# un cierre, es decir, podemos programar una función para programar otra función.
# Esta función le permitirá pasar una función, un valor mínimo y un valor máximo.
# Los valores fuera del rango se devolverán nuevamente con NA:
limitRange <- function(fun, min, max){
function(x){
y = fun(x)
y[x < min | x > max] <- NA
return(y)
}
}
#this returns a function
dlimit <- limitRange(dnorm, 0, 2)
dlimit(-2,4)
# Get data from year 2009
x <- subset(countries, Year == 2009)
# Drop rows that have any NA values
x <- x[complete.cases(x), ]
x <- x[sample(1:nrow(x), 25), ]
x
#install.packages("rgl")
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
type = "s",
size = 0.75,
lit = FALSE)
#De forma predeterminada, plot3d() usa puntos cuadrados, que no aparecen
# correctamente al guardar en un PDF. Para mejorar la apariencia, usamos type="s"
# para los puntos esféricos, los hicimos más pequeños con size=0.75 y apagamos la
# iluminación 3D con lit=FALSE (de lo contrario, se ven como esferas brillantes).
# Function to interleave the elements of two vectors
interleave <- function(v1, v2) as.vector(rbind(v1,v2))
# Plot the points
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab="Weight", ylab="Displacement", zlab="MPG",
size=.75, type="s", lit=FALSE)
# Add the segments
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha=0.4, col="blue")
# Make plot without axis ticks or labels
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab = "", ylab = "", zlab = "",
axes = FALSE,
size=.75, type="s", lit=FALSE)
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha = 0.4, col = "blue")
# Draw the box.
rgl.bbox(color="grey50", # grey60 surface and black text
emission="grey50", # emission color is grey50
xlen=0, ylen=0, zlen=0) # Don't add tick marks
# Set default color of future objects to black
rgl.material(color="black")+
# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges=c("x--", "y+-", "z--"),
ntick=6, # Attempt 6 tick marks on each side
cex=.75) # Smaller font
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
type = "s",
size = 0.75,
lit = FALSE)
#De forma predeterminada, plot3d() usa puntos cuadrados, que no aparecen
# correctamente al guardar en un PDF. Para mejorar la apariencia, usamos type="s"
# para los puntos esféricos, los hicimos más pequeños con size=0.75 y apagamos la
# iluminación 3D con lit=FALSE (de lo contrario, se ven como esferas brillantes).
# Function to interleave the elements of two vectors
interleave <- function(v1, v2) as.vector(rbind(v1,v2))
# Plot the points
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab="Weight", ylab="Displacement", zlab="MPG",
size=.75, type="s", lit=FALSE)
# Add the segments
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha=0.4, col="blue")
# Make plot without axis ticks or labels
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab = "", ylab = "", zlab = "",
axes = FALSE,
size=.75, type="s", lit=FALSE)
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha = 0.4, col = "blue")
# Draw the box.
rgl.bbox(color="grey50", # grey60 surface and black text
emission="grey50", # emission color is grey50
xlen=0, ylen=0, zlen=0) # Don't add tick marks
# Set default color of future objects to black
rgl.material(color="black")+
# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges=c("x--", "y+-", "z--"),
ntick=6, # Attempt 6 tick marks on each side
cex=.75) # Smaller font
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
type = "s",
size = 0.75,
lit = FALSE)
#De forma predeterminada, plot3d() usa puntos cuadrados, que no aparecen
# correctamente al guardar en un PDF. Para mejorar la apariencia, usamos type="s"
# para los puntos esféricos, los hicimos más pequeños con size=0.75 y apagamos la
# iluminación 3D con lit=FALSE (de lo contrario, se ven como esferas brillantes).
# Function to interleave the elements of two vectors
interleave <- function(v1, v2) as.vector(rbind(v1,v2))
# Plot the points
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab="Weight", ylab="Displacement", zlab="MPG",
size=.75, type="s", lit=FALSE)
# Add the segments
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha=0.4, col="blue")
# Make plot without axis ticks or labels
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab = "", ylab = "", zlab = "",
axes = FALSE,
size=.75, type="s", lit=FALSE)
segments3d(interleave(mtcars$wt, mtcars$wt),
interleave(mtcars$disp, mtcars$disp),
interleave(mtcars$mpg, min(mtcars$mpg)),
alpha = 0.4, col = "blue")
# Draw the box.
rgl.bbox(color="grey50", # grey60 surface and black text
emission="grey50", # emission color is grey50
xlen=0, ylen=0, zlen=0) # Don't add tick marks
# Set default color of future objects to black
rgl.material(color="black")+
# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges=c("x--", "y+-", "z--"),
ntick=6, # Attempt 6 tick marks on each side
cex=.75) # Smaller font
# Given a model, predict zvar from xvar and yvar
# Defaults to range of x and y variables, and a 16x16 grid
predictgrid <- function(model, xvar, yvar, zvar, res = 16, type = NULL) {
# Find the range of the predictor variable. This works for lm and glm
# and some others, but may require customization for others.
xrange <- range(model$model[[xvar]])
yrange <- range(model$model[[yvar]])
newdata <- expand.grid(x = seq(xrange[1], xrange[2], length.out = res),
y = seq(yrange[1], yrange[2], length.out = res))
names(newdata) <- c(xvar, yvar)
newdata[[zvar]] <- predict(model, newdata = newdata, type = type)
newdata
}
# Convert long-style data frame with x, y, and z vars into a list
# with x and y as row/column values, and z as a matrix.
df2mat <- function(p, xvar = NULL, yvar = NULL, zvar = NULL) {
if (is.null(xvar)) xvar <- names(p)[1]
if (is.null(yvar)) yvar <- names(p)[2]
if (is.null(zvar)) zvar <- names(p)[3]
x <- unique(p[[xvar]])
y <- unique(p[[yvar]])
z <- matrix(p[[zvar]], nrow = length(y), ncol = length(x))
m <- list(x, y, z)
names(m) <- c(xvar, yvar, zvar)
m
}
# Make a copy of the data set
m <- mtcars
# Generate a linear model
mod <- lm(mpg ~ wt + disp + wt:disp, data = m)
# Get predicted values of mpg from wt and disp
m$pred_mpg <- predict(mod)
# Get predicted mpg from a grid of wt and disp
mpgrid_df <- predictgrid(mod, "wt", "disp", "mpg")
mpgrid_list <- df2mat(mpgrid_df)
# Make the plot with the data points
plot3d(m$wt, m$disp, m$mpg, type="s", size=0.5, lit=FALSE)+
# Add the corresponding predicted points (smaller)
spheres3d(m$wt, m$disp, m$pred_mpg, alpha=0.4, type="s", size=0.5, lit=FALSE)+
# Add line segments showing the error
segments3d(interleave(m$wt, m$wt),
interleave(m$disp, m$disp),
interleave(m$mpg, m$pred_mpg),
alpha=0.4, col="red")+
# Add the mesh of predicted values
surface3d(mpgrid_list$wt, mpgrid_list$disp, mpgrid_list$mpg,
alpha=0.4, front="lines", back="lines")
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
xlab = "", ylab = "", zlab = "",
axes = FALSE,
size=.5, type="s", lit=FALSE)
# Add the corresponding predicted points (smaller)
spheres3d(m$wt, m$disp, m$pred_mpg, alpha=0.4, type="s", size=0.5, lit=FALSE)+
# Add line segments showing the error
segments3d(interleave(m$wt, m$wt),
interleave(m$disp, m$disp),
interleave(m$mpg, m$pred_mpg),
alpha=0.4, col="red")+
# Add the mesh of predicted values
surface3d(mpgrid_list$wt, mpgrid_list$disp, mpgrid_list$mpg,
alpha=0.4, front="lines", back="lines")
# Draw the box
rgl.bbox(color="grey50", # grey60 surface and black text
emission="grey50", # emission color is grey50
xlen=0, ylen=0, zlen=0) # Don't add tick marks
# Set default color of future objects to black
rgl.material(color="black")
# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges=c("x--", "y+-", "z--"),
ntick=6, # Attempt 6 tick marks on each side
cex=.75)+ # Smaller font
# Add axis labels. 'line' specifies how far to set the label from the axis.
mtext3d("Weight", edge="x--", line=2)
mtext3d("Displacement", edge="y+-", line=3)
mtext3d("MPG", edge="z--", line=3)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg, type="s", size=0.75, lit=FALSE)
rgl.snapshot('3dplot.png', fmt='png')
rgl.postscript('figs/miscgraph/3dplot.pdf', fmt='pdf')
rgl.postscript('figs/miscgraph/3dplot.ps', fmt='ps')
# Save the current viewpoint
view <- par3d("userMatrix")
# Restore the saved viewpoint
par3d(userMatrix = view)
dput(view)
view <- structure(c(0.907931625843048, 0.267511069774628, -0.322642296552658,
0, -0.410978674888611, 0.417272746562958, -0.810543060302734,
0, -0.0821993798017502, 0.868516683578491, 0.488796472549438,
0, 0, 0, 0, 1), .Dim = c(4L, 4L))
par3d(userMatrix = view)
dput(view)
#13.10. Animating a Three-Dimensional Plot
#13.10. Animación de un grafico tridimensional
plot3d(mtcars$wt,
mtcars$disp,
mtcars$mpg,
type = "s",
size = 0.75,
lit = FALSE)
play3d(spin3d())
# Spin on x-axis, at 4 rpm, for 20 seconds
play3d(spin3d(axis=c(1,0,0), rpm=4), duration=20)
plot3d(mtcars$wt,
mtcars$disp,
mtcars$mpg,
type = "s",
size = 0.75,
lit = FALSE)
play3d(spin3d())
# Spin on x-axis, at 4 rpm, for 20 seconds
play3d(spin3d(axis=c(1,0,0), rpm=4), duration=20)
# Spin on z axis, at 4 rpm, for 15 seconds
movie3d(spin3d(axis=c(0,0,1), rpm=4), duration=15, fps=50)
# Get data from year 2009
x <- subset(countries, Year == 2009)
# Drop rows that have any NA values
x <- x[complete.cases(x), ]
x <- x[sample(1:nrow(x), 25), ]
x
x <- x[, 4:7]
x
y <- scale(x)
y
dendrogram <- hclust(dist(y))
#make the dendrogram
plot(dendrogram)
#with tex aligned
plot(hc, hang = -1)
#with tex aligned
plot(dendrogram, hang = -1)
view(isabel)
str(isabel)
head(isabel)
str(isabel)
head(isabel, 3)
tail(isabel, 3)
islice <- subset(isabel, z == min(z))
islice %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50,
size = 0.25
))
islice %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50,
size = 0.90
))
islice %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50,
size = 0.10
))
islice %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50,
size = 0.25
))
# Take a slice where z is equal to the minimum value of z
islice <- subset(isabel, z == min(z))
# Keep 1 out of every 'by' values in vector x
every_n <- function(x, by = 2) {
x <- sort(x)
x[seq(1, length(x), by = by)]
}
# Keep 1 of every 4 values in x and y
keepx <- every_n(unique(isabel$x), by=4)
keepy <- every_n(unique(isabel$y), by=4)
# Keep only those rows where x value is in keepx and y value is in keepy
islicesub <- subset(islice, x %in% keepx & y %in% keepy)
library(grid)
islice %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50
),
size = 0.25)
islicesub %>%
ggplot(aes(
x = x,
y = y
))+
geom_segment(aes(
xend = x + vx/50,
yend = y + vy/50
),
arrow = arrow(length = unit(0.1, "cm")),
size = 0.25)
# The existing 'speed' column includes the z component. We'll calculate
# speedxy, the horizontal speed.
islicesub$speedxy <- sqrt(islicesub$vx^2 + islicesub$vy^2)
# Map speed to alpha
ggplot(islicesub, aes(x=x, y=y)) +
geom_segment(aes(xend = x+vx/50, yend = y+vy/50, alpha = speed),
arrow = arrow(length = unit(0.1,"cm")
# Get USA map data
usa <- map_data("usa")
# Get USA map data
usa <- map_data("usa")
1
installed.packages("maps")
installed.packages("maps")
library(maps)
install.packages("maps")
#installed.packages("maps")
library(maps)
# Get USA map data
usa <- map_data("usa")
# Map speed to colour, and set go from "grey80" to "darkred"
ggplot(islicesub, aes(x=x, y=y)) +
geom_segment(aes(xend = x+vx/50, yend = y+vy/50, colour = speed),
arrow = arrow(length = unit(0.1,"cm")), size = 0.6) +
scale_colour_continuous(low="grey80", high="darkred") +
geom_path(aes(x=long, y=lat, group=group), data=usa) +
coord_cartesian(xlim = range(islicesub$x), ylim = range(islicesub$y))
# Keep 1 out of every 5 values in x and y, and 1 in 2 values in z
keepx <- every_n(unique(isabel$x), by=5)
keepy <- every_n(unique(isabel$y), by=5)
keepz <- every_n(unique(isabel$z), by=2)
isub <- subset(isabel, x %in% keepx & y %in% keepy & z %in% keepz)
ggplot(isub, aes(x=x, y=y)) +
geom_segment(aes(xend = x+vx/50, yend = y+vy/50, colour = speed),
arrow = arrow(length = unit(0.1,"cm")), size = 0.5) +
scale_colour_continuous(low="grey80", high="darkred") +
facet_wrap( ~ z)
#QQ pot height
qqnorm(heightweight$weightLb)
ggline(heightweight$weightLb)
qqnorm(heightweight$weightLb)+
qqline(heightweight$weightLb)
qqnorm(heightweight$weightLb)
qqline(heightweight$weightLb)
# QQ plot of age
qqnorm(heightweight$ageYear)
qqline(heightweight$ageYear)
heightweight %>%
ggplot(aes(
x = heightIn
))+
stat_ecdf()
heightweight %>%
ggplot(aes(
x = ageYear
))+
stat_ecdf()
view(UCBAdmissions)
view(UCBAdmissions)
str(UCBAdmissions)
head(UCBAdmissions, 3)
tail(UCBAdmissions, 3)
ftable(UCBAdmissions)
dimnames(UCBAdmissions)
install.packages("vcd")
#install.packages("vcd")
library(vcd)
# Split by Admit, then Gender, then Dept
mosaic( ~ Admit + Gender + Dept,
data = UCBAdmissions)
mosaic( ~ Dept + Gender + Admit, data=UCBAdmissions,
highlighting="Admit", highlighting_fill=c("lightblue", "pink"),
direction=c("v","h","v"))
mosaic( ~ Dept + Gender + Admit, data=UCBAdmissions,
highlighting="Admit", highlighting_fill=c("lightblue", "pink"),
direction=c("v", "v", "h"))
# This order makes it difficult to compare male and female
mosaic( ~ Dept + Gender + Admit, data=UCBAdmissions,
highlighting="Admit", highlighting_fill=c("lightblue", "pink"),
direction=c("v", "h", "h"))
x <- table(survey$Fold)
x
str(survey)
view(MASS)
# Make the pie chart
pie(fold)
# Make the pie chart
pie(x)
# Get a table of how many cases are in each level of fold
x <- table(survey$Fold)
x
# Make the pie chart
pie(x)
# Get a table of how many cases are in each level of fold
library(MASS)
x <- table(survey$Fold)
x
# Make the pie chart
pie(x)
str(survey)
pie(c(99, 18, 120), labels=c("L on R", "Neither", "R on L"))
states_map <- map_data("state")
states_map
states_map %>%
ggplot(aes(
x = long,
y = lat,
group = group
))+
geom_polygon(fill = "white",
colour = "black")
states_map %>%
ggplot(aes(
x = long,
y = lat,
group = group
))+
geom_path()
states_map %>%
ggplot(aes(
x = long,
y = lat,
group = group
))+
geom_path()+
coord_map("mercator")
#install.packages("mapproj")
library(mapproj)
states_map %>%
ggplot(aes(
x = long,
y = lat,
group = group
))+
geom_path()+
coord_map("mercator")
world_map <- map_data("world")
world_map
sort(unique(world_map$region))
south_american <- map_data("world",
region = "Bolivia", "Chile", "Argentina", "Peru")
south_american <- map_data("world",
region = c("Bolivia", "Chile", "Argentina", "Peru"))
south_american %>%
ggplot(aes(
x = long,
y = lat,
group = group,
fill = region
))+
geom_polygon(colour = "black")+
scale_fill_brewer(palette = "Set2")
bo <- map_data("world",
region = "Bolivia")
bo %>%
ggplot(aes(
x = long,
y = lat,
group = group
))+
geom_path()
x <- map_data("bo")
ggplot(x, aes(x=long, y=lat, group=group)) + geom_path()
x <- map_data("BO")
ggplot(x, aes(x=long, y=lat, group=group)) + geom_path()
